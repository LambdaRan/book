

太快定义变量可能造成效率上的拖延；
过度使用转型可能导致代码变慢又难维护，又招来微妙难解的错误；
返回对象“内部数据之号码牌（handles）”可能会破坏封装并留给客户虚吊号码牌（dangling handles）；
未考虑异常带来的冲击则可能导致资源泄漏和数据败坏；
过度热心的inlining可能引起代码膨胀；
过度耦合（coupling）则可能导致让人不满意的冗长建置时间（build times）；


条款26：尽可能延后变量定义式的出现时间

延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初始实参为止。

对于循环变量：主要看赋值成本的大小
// 方法A：变量定义于循环外
Widget w;
for (int i = 0; i < n; ++i)
{
    w = 取决于i的某个值；
}
// 方法B：变量定义于循环内
for (int i = 0; i < n; ++i)
{
    Widget w（取决于i的某个值）；
}
做法A：1个构造函数 + 1个析构函数 + n个赋值操作；
做法B：n个构造函数 + n个析构函数

如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n值很大的时候。
    否则做法B或许较好。
    因此除非（1）你知道赋值成本比“构造+析构”成本低，（2）你正在处理代码中效率高度敏感的部分，
        否则你应该使用做法B。

请记住：
    尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。
