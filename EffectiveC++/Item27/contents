



条款27：尽量少做转型动作

C风格的转型动作：
    (T))expression
    T(expression)

C++四种新式转型：
    const_cast<T>(expression);
    dynamic_cast<T>(expression);
    reinterpret_cast<T>(expression);
    static_cast<T>(expression);

const_cast:
    通常被用来将对象的常量性转除。它也是唯一有此功能的C++style转型操作符。
dynamic_cast：
    主要用来执行“安全向下转型”，也就是用来决定某个对象是否归属于继承体系中的某个类型。
        它是唯一无法由旧式语法执行的动作，也是唯一可能耗费大量运行成本的转型动作。
reinterpret_cast：
    意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。
static_cast：
    用来强迫隐式转换，他也可以用来执行上述多种转换的反向转换。

任何一个类型转换（不论是通过转型操作而进行的显示转换，或通过编译器完成的隐式转换）往往真的
    令编译器编译出运行期间执行的代码。

单一对象可能拥有一个及以上的地址。

对象的布局方式和它们的地址计算方式随编译器的不同而不同。

避免使用dynamic_cast的一般做法：
    1.使用容器并在其中存储直接指向derived class对象的指针（通常是智能指针），
        如此便消除“通过base class接口处理对象”的需要。
    2.在base class内提供virtual函数做你想对派生类做的事。

请记住：
    如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。
        如果有个设计需要转型动作，试着发展无需转型的替换设计。
    如果转型是必要的，试着将它隐藏与某个函数背后。客户随后可以调用此函数，而不需要将转型放进他们自己的代码中。
    宁可使用C++style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的执掌。