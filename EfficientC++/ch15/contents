

可扩展性


15.1 对称多处理器架构
    总线是性能的瓶颈
    缓存一致问题

15.2 Amdahl定律

15.3 多线程与同步

15.4 将任务分解为多个子任务

15.5 缓存共享数据
    通过形参传递

15.6 无共享
    栈成员变量

15.7 部分共享

15.8 锁粒度

15.9 伪共享
    缓存行

15.10 惊群现象
    所有阻塞线程都被唤醒，竞争某一资源

15.11 读写锁

15.12 要点

    实现可扩展性的技巧是减少或者消除顺序化的代码。

    任务分解　将大的任务分解为小任务，使线程并发地执行这些小任务
    代码移出　临界区应该只包含关键代码，不直接操作共享资源的代码不要放在临界区内
    利用缓存　有时，通过缓存之前访问过的数据，可以消除对临界区的访问
    无共享　　如果需要少量、数目固定的资源实例，可以不使用公共资源池。可以把这些资源实例设为线程私有，并最后回收
    部分共享　有两个一样的资源池可以减少一半的竞争
    锁粒度　　不要用同样的锁来保护所有资源，除非这些资源是同时更新的
    伪共享　　不要在类定义里把两个使用频率都很高的锁放的太靠近。你肯定不希望他们共享同一个缓存行并触发一致性风暴
    惊群现象　仔细分析你的锁调用的特征。当锁被释放时，是所有等待线程都被唤醒还是只是唤醒一个线程？唤醒所有线程威胁到应用的可扩展性
    系统和类库调用　考察这些调用的实现特征。他们有可能是隐藏了顺序化的代码
    读写锁　以读为主的共享数据会从这种锁中获益，使用这种锁，可以消除读者线程之间的竞争

