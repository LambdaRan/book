虚函数

3.1 虚函数的构造
    内联是在编译时决定的。编译器不可能把运行时才解析的虚函数设置为内联。

    为了消除虚函数调用，必须允许编译器在编译期间就解析函数的绑定。
    通过对类进行硬编码或者将他作为模板参数来传递，可以避免使用动态绑定。

3.2 模板和继承

    因为函数调用的动态绑定是继承的结果，所以消除动态绑定的一种方法是基于模板的设计来替代继承。 运行期--》编译期

    硬编码： 每个类单独实现 几个类共有的功能。
        class A {};
        class B {};
        class C {
            private:
                A a_; // 将使用的其他类硬编码到类中
        };

    继承： 将共有的功能作为基类， 其他各类继承基类。 
        class A {}；
        class B ：public A {};
        class C {
            C (B *b) : b_(b) {}
            private:
                B *b_; // 基类指针指向派生类，实现多态
        }

    模板： 将共有的功能作为模板类型参数。
        class A {};
        class B {};

        template<typename T>
        class C {
            private:
                T t_;
        };

        C<A> c1;
        C<B> c2;

要点：
    虚函数的效率问题主要是 不能内联。
    模板比继承提供更好的性能。 

    
