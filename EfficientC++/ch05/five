
临时对象

5.1 对象定义
    使用类型不匹配初始化一个对象时，产生临时对象。
    但是大多数编译器优化省去了临时对象，所以效率上等价。
    Rational r1(100);
    Rational r2 = Rational(100);
    Rational r3 = 100; // 此处注意

5.2 类型不匹配

    类型不匹配容易产生临时对象。
    编译器通过　构造函数　来隐式转换。
    避免隐式转换：
        explicit 修饰构造函数
        重载赋值运算符　operator=();
        
    把常量表达式移到循环之外是一种简单且常见的优化方法。
    例:
    {
        Complex a, b;
        ...
        for (int i = 0; i < 100; ++i)
        {
            a = i*b + 1.0;//注意 1.0 重复创建临时对象
        }
    }
    改为：
    {
        Complex a, b;
        Complex one(1.0);
        ...
        for (int i = 0; i < 100; ++i)
        {
            a = i*b + one;
        }
    }

5.3 按值传递
    实参　－－》　形参

5.4 按值返回
ss
5.5 使用op=()消除临时对象

