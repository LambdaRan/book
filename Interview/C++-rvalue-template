
p121：
    当一个对象被用作右值的时候，用的是对象的值（内容）
    当对象被用作左值的时候，用的是对象的身份（在内存中的位置）

右值引用：P471
    一个重要性质：只能绑定到一个将要销毁的对象。
    
    一个右值引用也不过是某个对象的另一个名字而已。
    不能将一个右值引用绑定到一个左值上；

    返回左值引用的函数，连同赋值、下标、解引用和前置递增/减运算符，都是返回左值的表达式例子。
    返回非引用类型的函数，连同算术、关系、位以及后置定增/减运算符，都生成右值。
        可以将一个const的左值引用或一个右值引用绑定到这类表达式上。

    变量是左值
    右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

    变量表达式也有左值/右值属性。变量表达式都是左值。
        因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上。
        例如：
            int &&rr1 = 42;
            int &&rr2 = rr1; // 错误：表达式rr1是左值
    变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

P608
当一个函数参数是模板类型参数的一个普通（左值）引用时（即形如T&）
    只能传递给它一个左值
    template<typename T> void f(T &p);

如果一个函数参数的类型是const T&
    我们可以传递给它-- 一个对象（const或非const），一个临时对象或一个字面常量值。
    template<typename T> void f(const T &p);

当一个函数参数是模板类型参数的一个右值引用时（即形如T&&）
    //可以传递给它一个右值
    任意类型实参
    template<typename T> void f(T &&p);

我们不能将一个右值引用绑定到一个左值上，两个例外情况：
    1.影响将一个右值引用参数的推断如何进行。
        编译器推断模板类型参数为实参的左值引用类型。
        例如：
            template<typename T> void f(T &&p);
            int value = 32；
            f(value); // 此时 T为 int&
    1.如果我们间接创建一个引用的引用，则这些引用形成了“折叠”；
        X& &、X& &&和X&& &都折叠成类型X&
        类型X&& &&折叠成X&&

如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&），则他可以被绑定到一个左值，且
如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数函数参数将被实例化为一个（普通）左值引用参数（T&）

右值引用通常用于两种情况：
    模板转发其实参
    模板被重载

P613
如果一个函数蚕食是指向模板类型参数的右值引用，它对应的实参的const属性和左值/右值属性将得到保持。

当用于一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保持实参类型的所有细节

// 引用折叠
int& forward<int&>(int&);
int& forward<int&>(int&&);

int&& forward<int>(int&);
int&& forward<int>(int&&);

