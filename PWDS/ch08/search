

顺序查找：线性查找
    从头开始，逐个比较

优化：
    设置“哨兵”
        在查找方向的尽头放置“哨兵”免去在查找过程中每一次比较都要判断查找位置是否越界。提高效率
时间复杂度：O(N) 
平均查找次数：(n+1)/2


有序表查找：

    折半查找：二分查找
        前提：有序、顺序存储
        时间复杂度：O(log2(N))

    插值查找：
        根据要查找关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式：
            (key - a[low]) / (a[hight] - a[low])

        说明：在某些情况下算是折半查找的优化版本。
        折半查找： mid = (low + hight)/2 = low + (hight - low)/2
        插值查找： mid = low + ((key-a[low]) / (a[hight]-a[low])) * (hight-low)
        时间复杂度：O(log2(N))
            但对于表长较大，而关键字分布有比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好，反之。

    斐波那契查找：
        斐波那契查找利用黄金分割原理来实现的，每次移动F(k)个位置
        算法核心：
            当key=a[mid]时，查找成功
            当key<a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；
            当key>a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个；
        时间复杂度：O(log2(N)),当就平均性能来说，斐波那契查找要优于折半查找。
            最坏情况：一直处于某一长半区

折半查找：加法和除法运算
插值查找：复杂四则运算
斐波那契：简单加减运算
在海量数据查找方面，影响较大
