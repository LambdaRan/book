

// 寻找最大的k个数

// 解法一：如果数据量很小，可以使用快速排序或堆排序排序 然后找到前k个数
// 时间复杂度 O(N*log2(N)) + O(K) = O(N*log2(N))
// 部分排序算法： 选择排序和交换排序
// 时间复杂度 O(N*K)

// 解法二：利用快速排序的思想
// 避免对前k个数排序，只要知道是那几个数就可以
// 时间复杂度 O(N*log2(K))

// 解法三： 利用二分搜索策略
// 寻找最大的k个数中最小的那个
// 不是很明白

// 解法四：容量为K的最小堆来存储最大的K个数
// 时间复杂度 O(N*log2(K))

// 解法五：空间换取时间
// 如果所有N个数都是正整数，且他们的取值范围不太大，可以考虑申请空间，记录每个整数出现的次数
// 如果N个整数各不相同，我们可以考虑使用一个bit来存储这个整数